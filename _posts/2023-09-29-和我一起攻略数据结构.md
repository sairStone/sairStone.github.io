---
layout: post
title: '和我一起攻略数据结构'
date: 2023-09-28
author: Jekyll
color: rgb(255,210,32)
cover: '../assets/articleCover/cover3.jpg'
tags: 数据结构
typora-copy-images-to: ..\assets\dataStructImg
typora-root-url: ..\assets\dataStructImg
---

> 软件工程专业 数据结构攻略战

# 1.涉及书本

《C Primer Plus》 ——Stephen Prata (姜佑 译)

《数据结构教程 第6版》——李春葆

《数据结构学习指导 第6版 》——李春葆

《大话数据结构》——程杰

> 主要实现语言是C和C++

tips: C++ 更常见读法是CPP,来自于：C Plus Plus

# 2.打好基础

## 2.1 简短语言介绍

C语言是一种面向过程的开发语言

C更擅长操作硬件，所以偏向于嵌入式开发

C++ 旨在支持过程、面向对象的编程和泛型编程。 这是一种基于编译器的编程语言，因此经过静态类型化且区分大小写。 

C++可以制作Web浏览器、操作系统、数据库引擎、游戏、医疗工程、机器人、媒体应用程序等！

| 开发语言 | C                                      | C++                      |
| -------- | -------------------------------------- | :----------------------- |
| 设计思想 | 面向过程                               | 支持过程、面向对象       |
| 语法     | C的基础                                | 更多特性，更灵活         |
| 实际     | 更贴近底层                             | 更广阔开发               |
| 实际应用 | 开发系统级的软件，如操作系统、驱动程序 | 开发大型的应用程序和框架 |

记住一句话：C++是C的超集! 

> 解释：C++就是在C的基础上进行扩展，实现了封装、继承、多态等面向对象开发的功能，所以，使用C语言实现的代码绝大多数都能直接以C++的形式运行。



## 2.2 内容学习

### 2.2.1 基本语法

C++是面向对象，所以在学习前需要理解如下概念：

- **对象 -** 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。
- **类 -** 类可以定义为描述对象行为/状态的模板/蓝图。
- **方法 -** 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。
- **即时变量 -** 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。



在这里，我就不多说了，具体语法学习请前往菜鸟教程：

C++教程： https://www.runoob.com/cplusplus/cpp-tutorial.html

> 希望各位基本了解语法后，有实实在在地照着敲过代码后再进入后续章节！



### 2.2.2 语法技巧（后续填充）



# 3.数据结构

## 3.1 一起入门

### 3.1.1 定义

别的不说，先下个定义：

**数据结构就是有特定关系的数据元素的集合！**

> 解释：上学时有这么一张信息统计表，每个同学都有学号和姓名，{学号，姓名}这就是一个数据元素，全校有几千个学生，就代表这几千个数据元素组是一个集合。
>
> 每届不同专业不同班级的同学，相应的学号都有具体含义，比如说2023届入学的软件工程3班某某同学，学号是2023020313（2023代表入学时间，02代表软件工程专业，03代表属于3班，13代表在班级编号是第13号）
>
> 那么特定关系，相信你已经明白，你可以通过这个13号同学，接着联系到14号或者其他同学，知道他们是一个班、同一届、同一个学校。 （他们之间构成了联系）

所以：数据结构 = 数据 + 结构



### 3.1.2 逻辑结构

- **集合**：两个同学除了都是属于同校的关系，没有其他关系了。（集合）
- **线性结构**：竖排坐着的同学，都属于前后桌关系，**一对一**，上课传递纸条需要从开头往后面传。第一个同学叫**开始元素**，最后面的同学叫**终端元素**，除了这两个同学以外，每个同学都能接触到前一个同学和后一个同学，分别叫**前驱元素**和**后继元素**。（线性）
- **树形结构**：数据元素之间存在**一对多**的关系。就好比传销，最上面的人发展多个下线，每一个下线又发展出多个下线，从最上层往下走，一层比一层多。除了最上层的**根结点**以外，后面每层的人都有发展他上级，和他发展的下级。他的上级叫**前驱结点**，下级叫**后继结点**。（树形）
- **图形结构**：**多对多**的关系，一个老师对应多个班级的学生，这些班级的学生又对应着多个老师，每个老师都负责较多数量的学生，每个学生上着多个老师的课。

tips:树形和图形变成了平面，有了形状，而不是一条线！



### 3.1.3 存储结构

**逻辑结构**在计算机存储器这个硬件中的实际存储实现（即映像）！（了解即可）

以下常用：

1. **顺序**存储结构：以连续的存储单元存放，存储效率高。（一般以数组存储）
2. **链式**存储结构：不一定连续，但每个结点有指针域，指针域指向其他结点。（一般以链表来存储）
3. **索引**存储结构：以“关键字，地址”的形式建立索引表，利用关键字查找元素效率高。
4. **哈希（散列）**存储结构：通过哈希（散列）函数计算出一个值，作为该元素的存储地址。与前三种不同在，只存储元素的数据，不存储元素的逻辑关系，适用于快速查找和插入。

实际使用时，可以单独使用，也可以组合（具体实现，且等后续学习）



### 3.1.4 数据运算

数据运算就是对数据结构进行操作！

操作包含：查找、插入、删除、更新、排序等！



### 3.1.5 数据类型和抽象数据类型

数据类型：指**性质相同**的值的**集合**及定义在此集合上一些**操作**的总称。

数据类型分两类：

- **原子类型：**不可再分解的基本类型，包括整形、实型、字符型等。
- **结构类型：**由若干个类型组合成，可再分解。如：整形数组由若干整形数据组成。



常用数据数据类型：

1. 基本数据类型：int,float,double,char,bool

2. 指针类型：以 * 声明的指针变量，对存放指针指向的变量的地址操作。（指针变量也有地址，只不过这个指针变量指向其他变量。）

3. 数组类型：如 int a[10];

4. 结构体类型：struct 关键词（在C++中class关键字和struct差别不大）

5. 共用体类型：union 很少使用，学习中暂不考虑

6. 自定义类型：使用typedef关键字 设置为其他的类型名

   
   

> 既然使用了C++,那么肯定需要面向对象！

抽象数据类型ADT（Abstract Data Type）：

一个数学模型及定义在模型上的一组操作。如：像制作游戏，把人物走动的上下左右出项出现，定义操作。

特征：数据抽象（用下面ADT的描述方法） 和 数据封装（对外部隐藏内部实现细节）

```
ADT 抽象数据类型名：
{
	数据对象：数据对象的声明
	数据关系：数据关系的声明
	基本运算：基本运算的声明
}
```

下面是把动物这个概念进行抽象的具体定义：

```
抽象数据类型Animal的定义如下：

ADT Animal
{
属性:
名称 (name): 表示动物的名称，类型为字符串
年龄 (age): 表示动物的年龄，类型为整数
性别 (gender): 表示动物的性别，类型为字符串

方法:
获取名称 (getName): 返回动物的名称
获取年龄 (getAge): 返回动物的年龄
获取性别 (getGender): 返回动物的性别
设置名称 (setName): 设置动物的名称
设置年龄 (setAge): 设置动物的年龄
设置性别 (setGender): 设置动物的性别
发出声音 (makeSound): 模拟动物发出声音的行为
}
```

上面把狗这个抽象类型让我们以实际C++代码具体实例一下：

```c++
// 抽象类 Animal
class Animal {
public:
    virtual void sound() const = 0; // 纯虚函数，用于发出动物的声音
    virtual void eat() const = 0; // 纯虚函数，用于描述动物的进食行为
};

// 具体派生类 Dog
class Dog : public Animal {
public:
    void sound() const override {
        cout << "汪汪汪!" << endl;
    }

    void eat() const override {
        cout << "狗狗正在啃骨头。" << endl;
    }
};

// 具体派生类 Cat
class Cat : public Animal {
public:
    void sound() const override {
        cout << "喵喵喵!" << endl;
    }

    void eat() const override {
        cout << "猫咪正在吃鱼。" << endl;
    }
};

int main() {
    Animal* animal1 = new Dog();
    Animal* animal2 = new Cat();

    animal1->sound(); // 输出：汪汪汪!
    animal1->eat(); // 输出：狗狗正在啃骨头。

    animal2->sound(); // 输出：喵喵喵!
    animal2->eat(); // 输出：猫咪正在吃鱼。

    delete animal1;
    delete animal2;

    return 0;
}
/*
这段代码定义了一个抽象类 Animal，它包含两个纯虚函数 sound() 和 eat()。然后通过派生类 Dog 和 Cat 分别实现这两个纯虚函数。在 main() 函数中，创建了一个指向 Dog 对象和一个指向 Cat 对象的指针，然后分别调用它们的成员函数 sound() 和 eat() 来展示多态性的特性。最后，记得释放内存，删除指针对象。
*/
```

**提醒**：抽象类不能进行实例化！

> 上面具体实现的代码中，animal从名字来理解，就是 ’动物‘的意思，而实例是指具体到单个对象，而’动物‘这个词语，明显不能进行指单个动物，只能由派生出来的Dog类继承Animal这个抽象类中的属性和操作，然后通过Dog()类来进行实例化，实例到具体的哪一条狗，它能够进行啃骨头。





# 4. 算法

算法（Algorithm）是对问题解决的描述，也可以是实际的代码实现！

```c++
//进行1~100的求和
伪代码说明算法：
1. 初始化变量sum为0
2. 循环变量i从1到100，每次递增1
    - 将i的值加到sum中
3. 输出sum

实际代码实现算法：
int i=1,sum=0,n=100;  //执行了1次
for(i =1 ;i<=n;i++){
	sum +=i;         //执行了n次
}
std::cout << "1到100之间，步长为1的和：" << sum << std::endl; //执行了1次
```

**算法的特性：**

- 输入：具有0或多个输入，大多算法输入参数是必要的
- 输出：至少由1个或多个输出
- 有穷性：有限的运行步骤，不会出现无限循环，在可接受的时间内
- 确定性：算法每一步骤具有确定的含义，不出现二义性
- 可行性：每一步可以运行的

> 在上面的实际代码实现中，就做到了算法的特性，输入即设置的初始值，输出就是循环累加后的值。

上面的代码中的语句加起来一共执行了1+n+1,也就是n+2次。由于算法的**时间复杂度**表示中，常量不计入，所以该for循环求和算法为**O(n)**

接下来看下面的代码：

```c++
// 高斯求和算法
int sum=0,n=100;  //执行了1次
sum = (1+n)*n/2;  //执行了1次
```

高斯求和算法思路：

![image-20230707070711555](/image-20230707070711555.png)



两个算法的结果都是 5050，可是很明显，高斯求和算法远比 for循环求和算法要好！

**高斯求和算法时间复杂度为O(1)，远比O(n)要快！**

**函数的渐近增长：**给定两个函数f(n)和g(n)，如果存在一个整数N，是的所有n>N,f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)



![image-20230707073727819](/image-20230707073727819.png)

算法的与最高次相乘的常数不重要

![image-20230707073854774](/image-20230707073854774.png)

算法中的常数和其他次要项常常可以忽略，要关注主项（最高阶项）阶数





大O记法

**时间复杂度：T ( n ）= O（ f ( n ) )**

随n的增大，T（n）增长最慢的算法称为最优算法

最常见的算法的时间复杂度：

O（1）常数阶，O（n）线性阶，O（n²）平方阶

![image-20230707074654373](/image-20230707074654373.png)



**推导大O阶方法**

![image-20230707081111493](/image-20230707081111493.png)

![image-20230707081123772](/image-20230707081123772.png)

对数阶的由来！！



![image-20230707081443527](/image-20230707081443527.png)

需要你的数学能力，还是高斯求和法。



![image-20230707081901643](/image-20230707081901643.png)

![image-20230707081909190](/image-20230707081909190.png)



![image-20230707082040260](/image-20230707082040260.png)



### 算法总结

算法的定义：算法就是对求解步骤的描述，计算机中就是指令的有序序列

算法的特性：输入、输出、有穷性、确定性、可行性

算法的设计要求：正确性、可读性、健壮性、高效率和低存储量

算法的度量方法：事后统计（不科学和准确）和事前分析估算（大O法）

推导大O阶

- 用常数1取代运行时间中的所有加法常数
- 在修改后的运行次数函数中，只保留最高项
- 如果最高阶存在且不是1，则去除与这个项相乘的常数



改进代码，优化算法，降低时间复杂度

![image-20230707083813680](/image-20230707083813680.png)



# 5.归纳

程序 = 数据结构 + 算法

类型声明与对象定义用于实现数据结构，而语句实现算法，描述程序的行为。

数据的逻辑结构映射到计算机中就是实际的存储结构，而数据的存储结构由具体算法来实现。

