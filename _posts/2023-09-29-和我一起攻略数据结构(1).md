---
layout: post
title: '和我一起攻略数据结构（1）'
date: 2023-09-28
author: Jekyll
color: rgb(255,210,32)
cover: '../assets/articleCover/cover3.jpg'
tags: 数据结构 概念
typora-copy-images-to: ..\assets\dataStructImg
typora-root-url: ..\assets\dataStructImg
---

> 软件工程专业 数据结构攻略战


- [涉及书本](#%E6%B6%89%E5%8F%8A%E4%B9%A6%E6%9C%AC)
- [打好基础](#%E6%89%93%E5%A5%BD%E5%9F%BA%E7%A1%80)
    - [简短语言介绍](#%E7%AE%80%E7%9F%AD%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D)
    - [内容学习](#%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0)
        - [基本语法](#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95)
        - [注意点](#%E6%B3%A8%E6%84%8F%E7%82%B9)
            - [指针调用与引用调用](#%E6%8C%87%E9%92%88%E8%B0%83%E7%94%A8%E4%B8%8E%E5%BC%95%E7%94%A8%E8%B0%83%E7%94%A8)
            - [cin,cin.getline,getline](#cincingetlinegetline)
- [数据结构](#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
    - [一起入门](#%E4%B8%80%E8%B5%B7%E5%85%A5%E9%97%A8)
        - [定义](#%E5%AE%9A%E4%B9%89)
        - [逻辑结构](#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84)
        - [存储结构](#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)
        - [数据运算](#%E6%95%B0%E6%8D%AE%E8%BF%90%E7%AE%97)
        - [数据类型和抽象数据类型](#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)
- [算法](#%E7%AE%97%E6%B3%95)
        - [算法总结](#%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93)
- [归纳](#%E5%BD%92%E7%BA%B3)



# 1.涉及书本

《C Primer Plus》 ——Stephen Prata (姜佑 译)

《数据结构教程 第6版》——李春葆

《数据结构学习指导 第6版 》——李春葆

《大话数据结构》——程杰

> 主要实现语言是C和C++

tips: C++ 更常见读法是CPP,来自于：C Plus Plus

# 2.打好基础

## 2.1 简短语言介绍

C语言是一种面向过程的开发语言

C更擅长操作硬件，所以偏向于嵌入式开发

C++ 旨在支持过程、面向对象的编程和泛型编程。 这是一种基于编译器的编程语言，因此经过静态类型化且区分大小写。 

C++可以制作Web浏览器、操作系统、数据库引擎、游戏、医疗工程、机器人、媒体应用程序等！

| 开发语言 | C                                      | C++                      |
| -------- | -------------------------------------- | :----------------------- |
| 设计思想 | 面向过程                               | 支持过程、面向对象       |
| 语法     | C的基础                                | 更多特性，更灵活         |
| 实际     | 更贴近底层                             | 更广阔开发               |
| 实际应用 | 开发系统级的软件，如操作系统、驱动程序 | 开发大型的应用程序和框架 |

记住一句话：C++是C的超集! 

> 解释：C++就是在C的基础上进行扩展，实现了封装、继承、多态等面向对象开发的功能，所以，使用C语言实现的代码绝大多数都能直接以C++的形式运行。



## 2.2 内容学习

### 2.2.1 基本语法

C++是面向对象，所以在学习前需要理解如下概念：

- **对象 -** 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。
- **类 -** 类可以定义为描述对象行为/状态的模板/蓝图。
- **方法 -** 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。
- **即时变量 -** 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。



在这里，我就不多说了，具体语法学习请前往菜鸟教程：

优秀的学习对象：https://blog.csdn.net/weixin_48560325?type=blog

C++教程： https://www.runoob.com/cplusplus/cpp-tutorial.html

> 希望各位基本了解语法后，有实实在在地照着敲过代码后再进入后续章节！



### 2.2.2 注意点

#### 2.2.2.1 指针调用与引用调用

指针调用：该方法把参数的地址赋值给形式参数。

引用调用：该方法把参数的引用赋值给形式参数。

​	两种调用方式都会修改形式参数会影响实际参数。

> ​	C++推出引用&就是为了减少指针*的使用！

在C++中，指针和引用都是用来间接访问其他对象或值的工具。它们都可以被用来修改和访问基本数据类型和复合数据类型，例如数组和结构。

下面是指针和引用在语法和使用上有一些重要的区别。

**指针**

**指针是一个变量**，其值为另一个变量的地址。我们可以通过指针来读取或修改其指向的变量的值。在C++中，我们使用“*****”来**声明一个指针**。

例如，我们有一个整数变量i，我们可以创建一个指向i的指针，如下：

```c++
int i = 5;
int *p;
p = &i; // p现在指向i
```

我们可以使用指针来访问和修改i的值：

```c++
*p = 10; // i的值现在是10
```

注意，如果指针没有初始化或者它指向了一个无效的内存地址（例如，它自己分配的内存），那么试图访问或修改该地址上的值可能会导致未定义的行为，这通常会导致程序崩溃。

**引用**

引用是另一个变量或对象的别名。引用一旦初始化后，就不能再被重新指向另一个变量或对象。

> 在语法上，引用看起来很像用&取地址运算符取得的结果，但是它们在**语义上有很大的不同**。

例如，我们可以创建一个整数引用：

```c++
int i = 5;
int &ref = i; // ref是i的别名
```

我们可以使用引用ref来访问和修改i的值，就像使用i一样：

```c++
int j = *ref; // j现在是i的值
```

然而，如果我们尝试让引用引用另一个不同的对象，编译器会报错。例如：

```c++
int j = 15;
ref = j; // 这是错误的，不能更改引用的对象
```

引用和指针的**主要区别**是：指针可以被重新赋值以指向另一个对象，而引用一旦被初始化指向一个对象后，就不能再被重新指向另一个对象。因此，引用更像是一个别名，而不是一个可以改变其值的变量。使用引用可以使我们的代码更清晰易读，尤其是在函数参数和返回值中。

> tips:  &放在声明中，或放在左值中，就表示引用；  但&符号放在右值中，就表示取地址符。

```c++
int i = 5;
int *p;
p = &i; // 指针p现在指向i，&是取地址符

int i = 5;
int &ref = i; // ref是i的别名，&是引用
```



#### 2.2.2.2 cin,cin.getline,getline

| 类别            | 作用                                                         |
| --------------- | ------------------------------------------------------------ |
| cin>>           | cin可以连续从键盘读取想要的数据，以空格、tab或换行作为分隔符 |
| cin.getline（） | 接收一个字符串，可以接收空格并输出                           |
| cin.get()       | 接收一个字符串，结束符默认为回车键                           |
| getline()       | 接收一个字符串，可以接收空格并输出，需包含“#include”         |

**1.cin>>**
cin是将标准输入流写入缓冲区，即从键盘输入。
cin涉及的头文件是#include.

```c++
int a;
std::cin >>a;
```

**2.cin.getline(字符数组名，接收长度)；**
输出打印一行
但是cin.getline()当输入超长时，会引起cin函数的错误，后面的cin操作将不再执行。

```c++
char s[10];
std::cin.getline(s,10);
```

**3.cin.get(字符数组名，接收长度，结束符)**

不说明结束符默认enter

以字符5作为结束符 会打印字符5之前所有值。

```c++
#include<iostream>
using namespace std;
int main()
{
	char s[10];
	cin.get(s,10,'5');
	cout << s;
	return 0;
}
```

**4、getline()**

getline(cin, inputLine)，其中 cin 是正在读取的输入流，而inputLine 是接收输入字符串的 string 变量的名称。
它遇到以下情况发生会导致生成的本字符串结束：
(1)到文件结束，(2)遇到函数的定界符，(3)输入达到最大限度。

```c++
#include<iostream>
#include<string>
int main()
{
	string s;
	getline(std::cin,s);
	cout << s;
	return 0;
}
```



# 3.数据结构

## 3.1 一起入门

### 3.1.1 定义

别的不说，先下个定义：

**数据结构就是有特定关系的数据元素的集合！**

> 解释：上学时有这么一张信息统计表，每个同学都有学号和姓名，{学号，姓名}这就是一个数据元素，全校有几千个学生，就代表这几千个数据元素组是一个集合。
>
> 每届不同专业不同班级的同学，相应的学号都有具体含义，比如说2023届入学的软件工程3班某某同学，学号是2023020313（2023代表入学时间，02代表软件工程专业，03代表属于3班，13代表在班级编号是第13号）
>
> 那么特定关系，相信你已经明白，你可以通过这个13号同学，接着联系到14号或者其他同学，知道他们是一个班、同一届、同一个学校。 （他们之间构成了联系）

所以：数据结构 = 数据 + 结构



### 3.1.2 逻辑结构

- **集合**：两个同学除了都是属于同校的关系，没有其他关系了。（集合）
- **线性结构**：竖排坐着的同学，都属于前后桌关系，**一对一**，上课传递纸条需要从开头往后面传。第一个同学叫**开始元素**，最后面的同学叫**终端元素**，除了这两个同学以外，每个同学都能接触到前一个同学和后一个同学，分别叫**前驱元素**和**后继元素**。（线性）
- **树形结构**：数据元素之间存在**一对多**的关系。就好比传销，最上面的人发展多个下线，每一个下线又发展出多个下线，从最上层往下走，一层比一层多。除了最上层的**根结点**以外，后面每层的人都有发展他上级，和他发展的下级。他的上级叫**前驱结点**，下级叫**后继结点**。（树形）
- **图形结构**：**多对多**的关系，一个老师对应多个班级的学生，这些班级的学生又对应着多个老师，每个老师都负责较多数量的学生，每个学生上着多个老师的课。

tips:树形和图形变成了平面，有了形状，而不是一条线！



### 3.1.3 存储结构

**逻辑结构**在计算机存储器这个硬件中的实际存储实现（即映像）！（了解即可）

以下常用：

1. **顺序**存储结构：以连续的存储单元存放，存储效率高。（一般以数组存储）
2. **链式**存储结构：不一定连续，但每个结点有指针域，指针域指向其他结点。（一般以链表来存储）
3. **索引**存储结构：以“关键字，地址”的形式建立索引表，利用关键字查找元素效率高。
4. **哈希（散列）**存储结构：通过哈希（散列）函数计算出一个值，作为该元素的存储地址。与前三种不同在，只存储元素的数据，不存储元素的逻辑关系，适用于快速查找和插入。

实际使用时，可以单独使用，也可以组合（具体实现，且等后续学习）



### 3.1.4 数据运算

数据运算就是对数据结构进行操作！

操作包含：查找、插入、删除、更新、排序等！



### 3.1.5 数据类型和抽象数据类型

数据类型：指**性质相同**的值的**集合**及定义在此集合上一些**操作**的总称。

数据类型分两类：

- **原子类型：**不可再分解的基本类型，包括整形、实型、字符型等。
- **结构类型：**由若干个类型组合成，可再分解。如：整形数组由若干整形数据组成。



常用数据数据类型：

1. 基本数据类型：int,float,double,char,bool

2. 指针类型：以 * 声明的指针变量，对存放指针指向的变量的地址操作。（指针变量也有地址，只不过这个指针变量指向其他变量。）

3. 数组类型：如 int a[10];

4. 结构体类型：struct 关键词（在C++中class关键字和struct差别不大）

5. 共用体类型：union 很少使用，学习中暂不考虑

6. 自定义类型：使用typedef关键字 设置为其他的类型名

   
   

> 既然使用了C++,那么肯定需要面向对象！

抽象数据类型ADT（Abstract Data Type）：

一个数学模型及定义在模型上的一组操作。如：像制作游戏，把人物走动的上下左右出项出现，定义操作。

特征：数据抽象（用下面ADT的描述方法） 和 数据封装（对外部隐藏内部实现细节）

```
ADT 抽象数据类型名：
{
	数据对象：数据对象的声明
	数据关系：数据关系的声明
	基本运算：基本运算的声明
}
```

下面是把动物这个概念进行抽象的具体定义：

```
抽象数据类型Animal的定义如下：

ADT Animal
{
属性:
名称 (name): 表示动物的名称，类型为字符串
年龄 (age): 表示动物的年龄，类型为整数
性别 (gender): 表示动物的性别，类型为字符串

方法:
获取名称 (getName): 返回动物的名称
获取年龄 (getAge): 返回动物的年龄
获取性别 (getGender): 返回动物的性别
设置名称 (setName): 设置动物的名称
设置年龄 (setAge): 设置动物的年龄
设置性别 (setGender): 设置动物的性别
发出声音 (makeSound): 模拟动物发出声音的行为
}
```

上面把狗这个抽象类型让我们以实际C++代码具体实例一下：

```c++
// 抽象类 Animal
class Animal {
public:
    virtual void sound() const = 0; // 纯虚函数，用于发出动物的声音
    virtual void eat() const = 0; // 纯虚函数，用于描述动物的进食行为
};

// 具体派生类 Dog
class Dog : public Animal {
public:
    void sound() const override {
        cout << "汪汪汪!" << endl;
    }

    void eat() const override {
        cout << "狗狗正在啃骨头。" << endl;
    }
};

// 具体派生类 Cat
class Cat : public Animal {
public:
    void sound() const override {
        cout << "喵喵喵!" << endl;
    }

    void eat() const override {
        cout << "猫咪正在吃鱼。" << endl;
    }
};

int main() {
    Animal* animal1 = new Dog();
    Animal* animal2 = new Cat();

    animal1->sound(); // 输出：汪汪汪!
    animal1->eat(); // 输出：狗狗正在啃骨头。

    animal2->sound(); // 输出：喵喵喵!
    animal2->eat(); // 输出：猫咪正在吃鱼。

    delete animal1;
    delete animal2;

    return 0;
}
/*
这段代码定义了一个抽象类 Animal，它包含两个纯虚函数 sound() 和 eat()。然后通过派生类 Dog 和 Cat 分别实现这两个纯虚函数。在 main() 函数中，创建了一个指向 Dog 对象和一个指向 Cat 对象的指针，然后分别调用它们的成员函数 sound() 和 eat() 来展示多态性的特性。最后，记得释放内存，删除指针对象。
*/
```

**提醒**：抽象类不能进行实例化！

> 上面具体实现的代码中，animal从名字来理解，就是 ’动物‘的意思，而实例是指具体到单个对象，而’动物‘这个词语，明显不能进行指单个动物，只能由派生出来的Dog类继承Animal这个抽象类中的属性和操作，然后通过Dog()类来进行实例化，实例到具体的哪一条狗，它能够进行啃骨头。





# 4. 算法

算法（Algorithm）是对问题解决的描述，也可以是实际的代码实现！

```c++
//进行1~100的求和
伪代码说明算法：
1. 初始化变量sum为0
2. 循环变量i从1到100，每次递增1
    - 将i的值加到sum中
3. 输出sum

实际代码实现算法：
int i=1,sum=0,n=100;  //执行了1次
for(i =1 ;i<=n;i++){
	sum +=i;         //执行了n次
}
std::cout << "1到100之间，步长为1的和：" << sum << std::endl; //执行了1次
```

**算法的特性：**

- 输入：具有0或多个输入，大多算法输入参数是必要的
- 输出：至少由1个或多个输出
- 有穷性：有限的运行步骤，不会出现无限循环，在可接受的时间内
- 确定性：算法每一步骤具有确定的含义，不出现二义性
- 可行性：每一步可以运行的

> 在上面的实际代码实现中，就做到了算法的特性，输入即设置的初始值，输出就是循环累加后的值。

上面的代码中的语句加起来一共执行了1+n+1,也就是n+2次。由于算法的**时间复杂度**表示中，常量不计入，所以该for循环求和算法为**O(n)**

接下来看下面的代码：

```c++
// 高斯求和算法
int sum=0,n=100;  //执行了1次
sum = (1+n)*n/2;  //执行了1次
```

高斯求和算法思路：

![image-20230707070711555](/image-20230707070711555.png)



两个算法的结果都是 5050，可是很明显，高斯求和算法远比 for循环求和算法要好！

**高斯求和算法时间复杂度为O(1)，远比O(n)要快！**

**函数的渐近增长：**给定两个函数f(n)和g(n)，如果存在一个整数N，是的所有n>N,f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)



![image-20230707073727819](/image-20230707073727819.png)

算法的与最高次相乘的常数不重要

![image-20230707073854774](/image-20230707073854774.png)

算法中的常数和其他次要项常常可以忽略，要关注主项（最高阶项）阶数





大O记法

**时间复杂度：T ( n ）= O（ f ( n ) )**

随n的增大，T（n）增长最慢的算法称为最优算法

最常见的算法的时间复杂度：

O（1）常数阶，O（n）线性阶，O（n²）平方阶

![image-20230707074654373](/image-20230707074654373.png)



**推导大O阶方法**

![image-20230707081111493](/image-20230707081111493.png)

![image-20230707081123772](/image-20230707081123772.png)

对数阶的由来！！



![image-20230707081443527](/image-20230707081443527.png)

需要你的数学能力，还是高斯求和法。



![image-20230707081901643](/image-20230707081901643.png)

![image-20230707081909190](/image-20230707081909190.png)



![image-20230707082040260](/image-20230707082040260.png)



### 算法总结

算法的定义：算法就是对求解步骤的描述，计算机中就是指令的有序序列

算法的特性：输入、输出、有穷性、确定性、可行性

算法的设计要求：正确性、可读性、健壮性、高效率和低存储量

算法的度量方法：事后统计（不科学和准确）和事前分析估算（大O法）

推导大O阶

- 用常数1取代运行时间中的所有加法常数
- 在修改后的运行次数函数中，只保留最高项
- 如果最高阶存在且不是1，则去除与这个项相乘的常数



改进代码，优化算法，降低时间复杂度

![image-20230707083813680](/image-20230707083813680.png)



# 5.归纳

程序 = 数据结构 + 算法

类型声明与对象定义用于实现数据结构，而语句实现算法，描述程序的行为。

数据的逻辑结构映射到计算机中就是实际的存储结构，而数据的存储结构由具体算法来实现。

